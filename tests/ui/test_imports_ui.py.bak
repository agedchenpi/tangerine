"""
UI tests for import configuration management.

Tests creating import configurations through the Streamlit UI.
"""
import pytest
import uuid
import os
import sys
from streamlit.testing.v1 import AppTest

# Ensure admin directory is in Python path
if '/app/admin' not in sys.path:
    sys.path.insert(0, '/app/admin')

from admin.services.import_config_service import get_config, list_configs


@pytest.mark.integration
@pytest.mark.ui
class TestImportsUI:
    """Test import config creation through Streamlit UI."""

    def test_create_import_config_via_ui(
        self,
        created_datasource,
        created_datasettype,
        db_transaction,
        clean_test_data
    ):
        """
        Test creating an import configuration through the UI form.

        Verifies:
        - Form submission with all required fields works
        - Success message appears
        - Database record is created correctly
        - All form values are persisted
        """
        # Load imports page
        original_cwd = os.getcwd()
        os.chdir('/app/admin')
        try:
            at = AppTest.from_file("pages/imports.py")
            at.run()
        finally:
            os.chdir(original_cwd)

        # Navigate to "Create New" tab (tab index 1)
        at.tabs[1].select()
        at.run()

        # Generate unique config name
        config_name = f"UITest_Config_{uuid.uuid4().hex[:8]}"

        # Select datasource and datasettype from selectboxes outside the form
        # (based on forms.py lines 103-108 and 152-158)
        at.selectbox(key="datasource_select").select(created_datasource['sourcename'])
        at.selectbox(key="datasettype_select").select(created_datasettype['typename'])
        at.run()

        # Fill form fields inside the form (import_config_form_create)
        # Based on forms.py render_import_config_form function

        # Configuration Name (line 201-205)
        at.text_input[0].set_value(config_name)

        # File Type selectbox (line 207-212) - select CSV (default is index 0)
        at.selectbox[0].select_index(0)

        # Import Strategy selectbox (line 223-228) - select first strategy
        at.selectbox[1].select_index(0)

        # Source Directory (line 240-244)
        at.text_input[1].set_value("/app/data/source")

        # File Pattern (line 246-250)
        at.text_input[2].set_value(r"test_.*\.csv")

        # Archive Directory (line 255-259)
        at.text_input[3].set_value("/app/data/archive")

        # Target Table (line 261-265)
        at.text_input[4].set_value("feeds.ui_test_table")

        # Metadata Label Source (line 272-277) - select 'filename'
        at.selectbox[2].select("filename")
        at.run()

        # Label Position Index (line 281-287) - number input
        at.number_input[0].set_value(1)

        # Date Source (line 302-307) - select 'filename'
        at.selectbox[3].select("filename")
        at.run()

        # Date Position Index (line 311-316) - number input
        at.number_input[1].set_value(0)

        # Date Format (line 336-340)
        at.text_input[5].set_value("yyyyMMdd")

        # Delimiter (line 345-349)
        at.text_input[6].set_value("_")

        # is_blob checkbox (line 352-356) - leave unchecked (default False)
        # is_active checkbox (line 360-364) - leave checked (default True)

        # Submit form
        at.form_submit_button[0].click()
        at.run()

        # Verify success message
        success_messages = [msg.value for msg in at.success]
        assert any(config_name in msg for msg in success_messages), \
            f"Expected success message with '{config_name}', got: {success_messages}"

        # Verify via service layer
        configs = list_configs()
        created_config = next(
            (c for c in configs if c['config_name'] == config_name), None
        )

        assert created_config is not None, \
            f"Config '{config_name}' not found in database"
        assert created_config['file_type'] == 'CSV'
        assert created_config['target_table'] == 'feeds.ui_test_table'
        assert created_config['datasource'] == created_datasource['sourcename']
        assert created_config['datasettype'] == created_datasettype['typename']
        assert created_config['source_directory'] == '/app/data/source'
        assert created_config['archive_directory'] == '/app/data/archive'
        assert created_config['file_pattern'] == r'test_.*\.csv'
        assert created_config['metadata_label_source'] == 'filename'
        assert created_config['dateconfig'] == 'filename'
        assert created_config['delimiter'] == '_'
        assert created_config['is_active'] is True

    def test_create_import_config_missing_reference_data(
        self,
        db_transaction,
        clean_test_data
    ):
        """
        Test that import config form shows warning when reference data is missing.

        Verifies:
        - Warning message appears when no datasources exist
        - Form is not displayed
        """
        # Load imports page without creating reference data
        original_cwd = os.getcwd()
        os.chdir('/app/admin')
        try:
            at = AppTest.from_file("pages/imports.py")
            at.run()
        finally:
            os.chdir(original_cwd)

        # Navigate to "Create New" tab
        at.tabs[1].select()
        at.run()

        # Verify warning message appears
        warning_messages = [msg.value for msg in at.warning]
        assert any('missing' in msg.lower() or 'required' in msg.lower()
                   for msg in warning_messages), \
            f"Expected warning about missing reference data, got: {warning_messages}"

    def test_import_config_validation_errors(
        self,
        created_datasource,
        created_datasettype,
        db_transaction,
        clean_test_data
    ):
        """
        Test form validation errors for invalid input.

        Verifies:
        - Empty config name shows error
        - Same source and archive directory shows error
        """
        # Load imports page
        original_cwd = os.getcwd()
        os.chdir('/app/admin')
        try:
            at = AppTest.from_file("pages/imports.py")
            at.run()
        finally:
            os.chdir(original_cwd)

        # Navigate to "Create New" tab
        at.tabs[1].select()
        at.run()

        # Select reference data
        at.selectbox(key="datasource_select").select(created_datasource['sourcename'])
        at.selectbox(key="datasettype_select").select(created_datasettype['typename'])
        at.run()

        # Leave config name empty
        at.text_input[0].set_value("")

        # Set same directory for source and archive (validation error)
        same_dir = "/app/data/same"
        at.text_input[1].set_value(same_dir)  # source
        at.text_input[3].set_value(same_dir)  # archive

        # Fill minimal other fields
        at.text_input[2].set_value(r".*\.csv")
        at.text_input[4].set_value("feeds.test")

        # Submit form
        at.form_submit_button[0].click()
        at.run()

        # Verify error messages
        error_messages = [msg.value for msg in at.error]
        assert len(error_messages) > 0, "Expected validation errors"
        assert any('different' in msg.lower() for msg in error_messages), \
            f"Expected error about same directories, got: {error_messages}"

    def test_import_config_with_static_metadata(
        self,
        created_datasource,
        created_datasettype,
        db_transaction,
        clean_test_data
    ):
        """
        Test creating import config with static metadata source.

        Verifies:
        - Can create config with static metadata label
        - Static values are persisted correctly
        """
        # Load imports page
        original_cwd = os.getcwd()
        os.chdir('/app/admin')
        try:
            at = AppTest.from_file("pages/imports.py")
            at.run()
        finally:
            os.chdir(original_cwd)

        # Navigate to "Create New" tab
        at.tabs[1].select()
        at.run()

        # Generate unique config name
        config_name = f"UITest_Static_{uuid.uuid4().hex[:8]}"

        # Select reference data
        at.selectbox(key="datasource_select").select(created_datasource['sourcename'])
        at.selectbox(key="datasettype_select").select(created_datasettype['typename'])
        at.run()

        # Fill form fields
        at.text_input[0].set_value(config_name)
        at.text_input[1].set_value("/app/data/source")
        at.text_input[2].set_value(r".*\.csv")
        at.text_input[3].set_value("/app/data/archive")
        at.text_input[4].set_value("feeds.static_test")

        # Select 'static' for metadata label source
        at.selectbox[2].select("static")
        at.run()

        # Fill static label value (text_input will appear dynamically)
        # After selecting 'static', a text_input for "Static Label Value" appears
        at.text_input[5].set_value("STATIC_LABEL")

        # Select 'static' for date source
        at.selectbox[3].select("static")
        at.run()

        # Fill static date value
        at.text_input[6].set_value("2026-01-01")

        # Date format
        at.text_input[7].set_value("yyyy-MM-dd")

        # Submit form
        at.form_submit_button[0].click()
        at.run()

        # Verify success
        success_messages = [msg.value for msg in at.success]
        assert any(config_name in msg for msg in success_messages)

        # Verify database
        configs = list_configs()
        created_config = next(
            (c for c in configs if c['config_name'] == config_name), None
        )

        assert created_config is not None
        assert created_config['metadata_label_source'] == 'static'
        assert created_config['metadata_label_location'] == 'STATIC_LABEL'
        assert created_config['dateconfig'] == 'static'
        assert created_config['datelocation'] == '2026-01-01'
